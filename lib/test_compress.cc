/* -*- c++ -*- */
/*
 * Copyright 2012 Free Software Foundation, Inc.
 *
 * This file was generated by gr_modtool, a tool from the GNU Radio framework
 * This file is a part of gr-compress
 *
 * GNU Radio is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3, or (at your option)
 * any later version.
 *
 * GNU Radio is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GNU Radio; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 51 Franklin Street,
 * Boston, MA 02110-1301, USA.
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <cppunit/TextTestRunner.h>
#include <cppunit/XmlOutputter.h>

#include <gnuradio/unittests.h>
#include "qa_compress.h"
#include <iostream>
#include <fstream>

#include <iomanip>
#include <boost/algorithm/string/replace.hpp>

#include <chrono>

#include "compress_impl.h"
#include "decompress_impl.h"

int largeBlockSize=64000;
int maxThreads=8;

using namespace gr::compress;

class comma_numpunct : public std::numpunct<char>
{
  protected:
    virtual char do_thousands_sep() const
    {
        return ',';
    }

    virtual std::string do_grouping() const
    {
        return "\03";
    }
};

void TestCompression() {
	compress_impl *test;
	test = new compress_impl(1,largeBlockSize,4,false,false);
	test->timeCompression();


	int i;
	std::chrono::time_point<std::chrono::steady_clock> start, end;
	std::chrono::duration<double> elapsed_seconds = end-start;
	std::vector<int> ninitems;

	std::vector<char> inputItems;
	std::vector<char> outputItems;
	std::vector<char> outputItems2;
	std::vector<const void *> inputPointers;
	std::vector<void *> outputPointers;

	char buffer[1];

	FILE *pFile;
	pFile = fopen("/opt/sdr/gnuradio/gr-compress/examples/test.bc","rb");

	if (!pFile) {
		std::cerr<< "ERROR opening file." << std::endl;
		exit(1);
	}

	size_t bytesRead = 1;
	int byteStreamSize = 0;

	while (bytesRead > 0) {
		bytesRead = fread(&buffer[0],1,1,pFile);

		if (bytesRead) {
			byteStreamSize += bytesRead;

			for (int i=0;i<bytesRead;i++) {
				inputItems.push_back(buffer[0]);
				outputItems.push_back(0);
			}
		}
	}

	fclose(pFile);
	inputPointers.push_back((const void *)&inputItems[0]);
	outputPointers.push_back((void *)&outputItems[0]);

	ninitems.push_back(byteStreamSize);

	std::cout << "----------------------------------------------------------" << std::endl;
	std::cout << "Read " << byteStreamSize << " real signal bytes from file." << std::endl;
	std::cout << "----------------------------------------------------------" << std::endl;

	int sizeofcomplex = sizeof(gr_complex);
	int complexSamples = byteStreamSize / (sizeofcomplex);

	std::cout << "Testing gnuradio compression call with " << byteStreamSize << " data block (equivilent to " << complexSamples << " complex samples)..." << std::endl;

	int noutputitems;
	int iterations = 100;
	float elapsed_time,throughput_original,throughput;

	noutputitems = test->test(byteStreamSize,inputPointers,outputPointers);

	start = std::chrono::steady_clock::now();
	// make iterations calls to get average.
	for (i=0;i<iterations;i++) {
		noutputitems = test->test(byteStreamSize,inputPointers,outputPointers);
	}
	end = std::chrono::steady_clock::now();

	elapsed_seconds = end-start;

	elapsed_time = elapsed_seconds.count()/(float)iterations;
	throughput_original = byteStreamSize / elapsed_time;
	float cs_throughput = complexSamples / elapsed_time;
	float s16_throughput = byteStreamSize / 4 / elapsed_time;
	float u8c_throughput = byteStreamSize / 2 / elapsed_time;

	std::cout << "Run Time:   " << std::fixed << std::setw(11)
    << std::setprecision(6) << elapsed_time << " s" << std::endl;
	std::cout << std::setprecision(2) << throughput_original << " Bps" << std::endl <<
				cs_throughput << " float complex sps" << std::endl <<
				s16_throughput << " Short complex (SC16) sps" << std::endl <<
				u8c_throughput << " byte complex (SC8) sps" << std::endl;


	std::cout << "----------------------------------------------------------" << std::endl;
	std::cout << "Testing gnuradio decompression call..." << std::endl;

	decompress_impl *decompTest;

	decompTest = new decompress_impl(1,false,false);

	const unsigned char *compressedData = test->getCompressedBuffer();
	size_t compressedSize = test->getCompressedSize();

	std::cout << "Compressed size: " << compressedSize << std::endl;
	float compressedRatio = ((float)compressedSize / (float)byteStreamSize * 100.0);
	std::cout << "Compressed ratio: " << compressedRatio << "%, " << (100.0-compressedRatio) << "% compression." << std::endl;
	inputItems.clear();

	for (int i=0;i<compressedSize;i++) {
		inputItems.push_back(compressedData[i]);
	}

	inputPointers.clear();
	inputPointers.push_back((const void *)&inputItems[0]);
	ninitems.clear();
	ninitems.push_back(compressedSize);

	noutputitems = decompTest->test(compressedSize,inputPointers,outputPointers,byteStreamSize,compressedSize);

	start = std::chrono::steady_clock::now();
	// make iterations calls to get average.

	for (i=0;i<iterations;i++) {
		noutputitems = decompTest->test(compressedSize,inputPointers,outputPointers,byteStreamSize,compressedSize);
	}
	end = std::chrono::steady_clock::now();

	elapsed_seconds = end-start;

	elapsed_time = elapsed_seconds.count()/(float)iterations;
	throughput_original = byteStreamSize / elapsed_time;
	cs_throughput = complexSamples / elapsed_time;
	s16_throughput = byteStreamSize / 4 / elapsed_time;
	u8c_throughput = byteStreamSize / 2 / elapsed_time;

	std::cout << "Run Time:   " << std::fixed << std::setw(11)
    << std::setprecision(6) << elapsed_time << " s" << std::endl;
	std::cout << std::setprecision(2) << throughput_original << " Bps" << std::endl <<
				cs_throughput << " float complex sps" << std::endl <<
				s16_throughput << " Short complex (SC16) sps" << std::endl <<
				u8c_throughput << " byte complex (SC8) sps" << std::endl;

	delete test;
	delete decompTest;
}

int
main (int argc, char **argv)
{
	/*
  CppUnit::TextTestRunner runner;
  std::ofstream xmlfile(get_unittest_path("compress.xml").c_str());
  CppUnit::XmlOutputter *xmlout = new CppUnit::XmlOutputter(&runner.result(), xmlfile);

  runner.addTest(qa_compress::suite());
  runner.setOutputter(xmlout);

  bool was_successful = runner.run("", false);

  return was_successful ? 0 : 1;
  */

	// Add comma's to numbers
	std::locale comma_locale(std::locale(), new comma_numpunct());

	// tell cout to use our new locale.
	std::cout.imbue(comma_locale);

	TestCompression();
	return 0;
}
